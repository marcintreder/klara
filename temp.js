#!/usr/bin/env node
const fse = require("fs-extra");
const path = require("path");
/* Fetch tools */
const fetch = require("node-fetch");
const download = require("download");
const remote = require("remote-file-size");
/* CLI Dependencies */
const progressBar = require("progress");
const Spinner = require("cli-spinner").Spinner;
const chalk = require("chalk");
/* Klara's tools and plugins */
const SVGO = require("svgo");
const svgSpriter = require("./svgSpriter");
const iconFontsCreator = require("./iconFontsCreator");
const pngConverter = require("./pngConverter");
const pngSpriter = require("./pngSpriter");
/* Config generated by CLI tool */
const config = require(`${process.cwd()}/icons.config.js`);

module.exports = function assetsDownloader() {
  const url = config.url; // UXPin DS data URL set in the config file
  // let directories = []; // All the directories that should be created for categories in the Data JSON from UXPin

  /* Set loader/spinner */
  const chalkSpinner = chalk.magentaBright("Processing... %s");
  const spinner = new Spinner(`${chalkSpinner}`);
  spinner.setSpinnerString("|/-\\");
  spinner.start();

  /* Fetch JSON from UXPin servers */
  fetch(url)
    .then(response => {
      return response.json();
    })
    .then(json => assetsIterator(json));

  /* Find assets categories and iterate over them */
  const assetsIterator = data => {
    const assets = data.find((obj, i) => obj.type === "assets");

    assets.categories.map(item => {
      return filesIterator(item);
    });
  };

  /* Iterate on files */
  const filesIterator = data => {
    /* Extract directory for category */
    const categoryDir = `./${data.name}`;
    // directories.push(categoryDir);
    /* Send all the files to the function responsible for download */
    const assetsArr = data.items.map(item => {
      /* Prepare object with assets data from JSON */
      const fileObj = new Object();
      fileObj.url = item.value.url;
      fileObj.name = item.name;
      fileObj.type = fileObj.url
        .substring(fileObj.url.lastIndexOf(".") + 1)
        .toLowerCase();
      fileObj.fullName = `${item.name}.${fileObj.type}`;
      fileObj.category = data.name;
      fileObj.directory = `${categoryDir}/${fileObj.type.toUpperCase()}`;
      fileObj.fullDirectory = `${fileObj.directory}/${fileObj.fullName}`;
      /* Create directory for currently transformed category of assets */
      fse.ensureDirSync(fileObj.directory);
      return fileObj;
    });
    return fileDownloader(categoryDir, assetsArr);
  };

  /* Download all the files at once, so files can be used for
  ** transformations such as Icon Fonts, Sprites and PNG from SVG creations.
   */
  const fileDownloader = (dir, assetsArr) => {
    /* Progress bar */
    const downloadMsg = chalk.greenBright(`✓ Downloading assets`);
    const bar = new progressBar(`${downloadMsg} ${dir}: :bar :current/:total`, {
      total: assetsArr.length
    });
    const svgo = new SVGO(config.svgo.settings);

    let singleTrigger = "available";

    /* Attempt to download all files */
    Promise.all(
      assetsArr.map(item =>
        download(item.url)
          .then(data => {
            /* When file exists check if there were any changes */
            if (fse.existsSync(item.fullDirectory)) {
              function fileTester() {
                /* Load local file to string and check its size.
                ** This is used to check whether online and local files
                ** are the same for non-svg file formats.
                */
                const localFile = fse.readFileSync(item.fullDirectory, "utf8");
                const localFileSize = fse.statSync(item.fullDirectory).size;
                /* Check if file is an SVG and if SVGO is active */
                if (item.type === "svg" && config.svgo.active) {
                  /* Optimize content of the file with SVGO so a comparison
                  ** of local optimized file and file store on the server
                  ** (pre–optimized) is going to be possible.
                   */
                  return svgo.optimize(data).then(function(result) {
                    if (result.data !== localFile) {
                      console.log(`Overwriting: ${item.fullName}`);
                      fse.writeFile(item.fullDirectory, result.data);
                      /* Return a promise with the relevant data for
                      ** other operations.
                       */
                      return Promise.resolve({
                        modified: item.directory,
                        fileName: item.fullName
                      });
                    } else {
                      /* If local and online files are identical – resolve the promise
                      ** with an 'unmodified' flag.
                       */
                      return Promise.resolve({ unmodified: item.directory });
                    }
                  });
                } else if (item.type === "svg" && !config.svgo.active) {
                  /* Files comparison when SVGO clean-up is turned off */
                  const svgString = data.toString();
                  if (svgString !== localFile) {
                    console.log(`Overwriting: ${item.fullName}`);
                    fse.writeFile(item.fullDirectory, data);
                    return Promise.resolve({
                      modified: item.directory,
                      fileName: item.fullName
                    });
                  } else {
                    return Promise.resolve({ unmodified: item.directory });
                  }
                } else if (item.type !== "svg") {
                  /* For non-svg files, compare the size on the server
                  ** with the locally stored file.
                   */
                  return new Promise((resolve, reject) => {
                    remote(item.url, (err, fileSize) => {
                      if (err) {
                        reject(err);
                      } else {
                        resolve(fileSize);
                      }
                    });
                  }).then(onlineSize => {
                    if (localFileSize !== onlineSize) {
                      console.log(`Overwriting: ${item.fullName}`);
                      fse.writeFileSync(item.fullDirectory, data);
                      return Promise.resolve({
                        modified: item.directory,
                        fileName: item.fullName
                      });
                    } else {
                      return Promise.resolve({ unmodified: item.directory });
                    }
                  });
                }
              }
              /* Callback for the fileTester function */
              return fileTester();
            } else {
              /* If a directory doesn't exist yet, create it
              ** and download all the files.
              */
              if (item.type === "svg" && config.svgo.active) {
                return svgo.optimize(data).then(function(result) {
                  fse.writeFileSync(item.fullDirectory, result.data);
                  return Promise.resolve({
                    modified: item.directory,
                    fileName: item.fullName
                  });
                });
              } else {
                fse.writeFileSync(item.fullDirectory, data);
                return Promise.resolve({
                  modified: item.directory,
                  fileName: item.fullName
                });
              }
            }
          })
          .catch(error => {
            console.log(error);
            return error;
          })
      )
    )
      .then(data => {
        /* Turn off spinner. Files have been downloaded. */
        spinner.stop(false);

        /* Check if any files have been saved or modified.
        ** If yes then data passed from the Promise should have
        ** items with key "modified".
        */
        const modifiedCategory = data.filter(item => {
          return item["modified"];
        });

        if (modifiedCategory.length > 0) {
          /* Extract category name */
          const category = modifiedCategory[0]["modified"];
          /* Read files from the category */
          const filesArr = fse.readdirSync(category);
          /* Find the file type(s) */
          const fileType = filesArr.reduce((a, b) => {
            const aType = a.substring(a.lastIndexOf(".") + 1).toLowerCase();
            const bType = b.substring(b.lastIndexOf(".") + 1).toLowerCase();
            if (aType === bType) {
              return aType;
            } else {
              return "multiple";
            }
          });

          if (fileType === "png") {
            config.pngSprite.active ? pngSpriter(category) : "";
          } else if (fileType === "svg") {
            config.webfontConfig.active ? iconFontsCreator(category) : "";
            config.svgSprite.active ? svgSpriter(category) : "";
            config.pngConverter.active ? pngConverter(modifiedCategory) : "";
          }
        } else {
          /* Currently no tools are ready to work with other
          ** formats than SVG and PNG. These files will be downloaded though.
          */
          return;
        }
      })
      .catch(error => {
        console.log(error);
        return error;
      });
  };
};
